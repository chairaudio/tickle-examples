import("stdfaust.lib");

      // as we need lots of filters in a row
      // we make use of fausts rewriting rules
      // to line them up recursively
hp_row(1) = fi.highpass(1, 4);
hp_row(n) = fi.highpass(1, 4) : hp_row(n-1);

      // now the dc offset remover
      // is providing two signals:
      // 1. DC as an envelope
      // 2. Clean signal
dc_offset = _ <: (_,_): (_, (hp_row(4))): 
    (_,(_<:(_,_))):
           ((-:fi.lowpass(1, 100) * 25),_);

x = (_,_)<:(!,_,_,!);

g(x) =
	(x, _, x, _, x, _, x,_) : (*,*,*,*);

mx(psi,damp) = 
	(cos(psi),_, sin(psi) * (-1),_, sin(psi),_, cos(psi),_) : (*,*,*,*) : g(damp);

udn(deltime, decay, gfactor) = 
	// Two inputs, one for each of the delaylines.
	((_,x,_) : (+,+) : (_,_) <: mx((gfactor * ma.PI),(1-(decay/10))) : (+,+)) ~ 
	(de.delay(ma.SR/5, deltime * 5 * ma.SR/1000),de.delay(ma.SR/5, deltime * 5 * ma.SR/1000)) : + ;

allp(decay, gfactor, deltime) = 
	// Here, the input will go to both delaylines.
	(_<:(_,_)) :
	(((_,x,_) : (+,+) : (_,_) <: mx((gfactor * ma.PI),(1-(decay/10))) : (+,+)) ~ 
	(de.delay(ma.SR/5, deltime * 5 * ma.SR/1000), de.delay(ma.SR/5, deltime * 5 * ma.SR/1000))) :
	//(fi.allpassn(5, (-0.1,0.1,-0.1,0.1,-0.11)),	fi.allpassn(5, (0.1,-0.1,0.1,-0.1,0.1))) :
	+ ;

allp0 = 
	(_,_,_) : 
	((_<:(_,_)),_,_) : 
	(((- (0.25)) : ((* (2 * ma.PI)) : cos)),((* (2 * ma.PI)) : cos),_,_) :
  (_,(_<:(_,_)),_,_) : ((_<:(_,_)),_,((_,_)<:(!,_,_,!)),_) : (_,((_,_)<:(!,_,_,!)),_,((_,_)<:(!,_,_,!))) :
	(_,_,((_,_)<:(!,_,_,!)),_,_) : (_,_,_,_,_,_) :
	(_,(((*),_,_,_ : (((_,_)<:(!,_,_,!)),_,_) : (_,_,_,(_<:(_,_))) : (_,_,*,_) : (_, +, _) :
	//de.fdelay4(ma.SR/10),_)  ~_ ),_) : (*,*) : (-);
	de.delay(ma.SR/10),_)  ~_ ),_) : (*,*) : (-);
	// (_,_,_):((*),_):(-);

