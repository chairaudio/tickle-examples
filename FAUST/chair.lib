import("stdfaust.lib");

      // as we need lots of filters in a row
      // we make use of fausts rewriting rules
      // to line them up recursively
hp_row(1) = fi.highpass(1, 4);
hp_row(n) = fi.highpass(1, 4) : hp_row(n-1);

      // now the dc offset remover
      // is providing two signals:
      // 1. DC as an envelope
      // 2. Clean signal
dc_offset = 
	_ <: (_,_) : 
	(_, (hp_row(4))) : 
	(_,(_<:(_,_))) :
	((- : fi.lowpass(1, 100) * 25),_);

x = (_,_)<:(!,_,_,!);

g(x) =
	(x, _, x, _, x, _, x,_) : (*,*,*,*);

mx(theta,damp) = 
	(cos(theta),_, sin(theta) * (-1),_, sin(theta),_, cos(theta),_) : (*,*,*,*) : g(damp);

// We need several of these.
// They differ in the organisation of the inputs and outputs,
// not in what they are doing.
mx0(theta,damp) = 
	(
		cos(theta * ma.PI * 2),_, 
		sin(theta * ma.PI * 2),_, 
		sin(theta * ma.PI * 2) * (-1),_, 
		cos(theta * ma.PI * 2),_
	) : (*,*,*,*) : g(damp);

schmalfuss(deltime, theta, gfactor) =
	// This delayline only processes the "imaginary" part of the signal
	(_<:(_,_)) : 
	(((_,x,_) :
	mx0((theta),(1-(gfactor/10))) : (+,+)) ~
	(de.delay(ma.SR/5, deltime * 5 * ma.SR/1000) <: (_,_))) : 
	(!,_);

udn(deltime, theta, gfactor) = 
	// Two inputs, one for each of the delaylines.
	// This is the unitary delay network as discribed in
	// "Infuriating nonlinear reverbarator" by Miller Puckette (ICMC 2011)
	((_,x,_) : (+,+) : (_,_) <: mx((theta * ma.PI),(1-(gfactor/10))) : (+,+)) ~ 
	(de.delay(ma.SR/5, deltime * 5 * ma.SR/1000),de.delay(ma.SR/5, deltime * 5 * ma.SR/1000)) : + ;

allp(gfactor, theta, deltime) = 
	// Here, the input will go to both delaylines.
	(_<:(_,_)) :
	(((_,x,_) : (+,+) : (_,_) <: mx((theta * ma.PI),(1-(gfactor/10))) : (+,+)) ~ 
	(de.delay(ma.SR/5, deltime * 5 * ma.SR/1000), de.delay(ma.SR/5, deltime * 5 * ma.SR/1000))) :
	//(fi.allpassn(5, (-0.1,0.1,-0.1,0.1,-0.11)),	fi.allpassn(5, (0.1,-0.1,0.1,-0.1,0.1))) :
	+ ;

allp1d(gfactor, theta, deltime) = 
	// Here, the input will go to both delaylines
	// and they are added to one delay
	// which might not actually make sense :-/
	(_<:(_,_)) :
	(((_,x,_) : (+,+) : (_,_) <: mx((theta * ma.PI),(1-(gfactor/10))) : (+,+)) ~ 
	( + : de.delay(ma.SR/5, deltime * 5 * ma.SR/1000) : (_<:(_,_)))) :
	//(fi.allpassn(5, (-0.1,0.1,-0.1,0.1,-0.11)),	fi.allpassn(5, (0.1,-0.1,0.1,-0.1,0.1))) :
	+ ;

// This is still here because it was a lot of work :_(
allp0 = 
	(_,_,_) : 
	((_<:(_,_)),_,_) : 
	(((- (0.25)) : ((* (2 * ma.PI)) : cos)),((* (2 * ma.PI)) : cos),_,_) :
  (_,(_<:(_,_)),_,_) : ((_<:(_,_)),_,((_,_)<:(!,_,_,!)),_) : (_,((_,_)<:(!,_,_,!)),_,((_,_)<:(!,_,_,!))) :
	(_,_,((_,_)<:(!,_,_,!)),_,_) : (_,_,_,_,_,_) :
	(_,(((*),_,_,_ : (((_,_)<:(!,_,_,!)),_,_) : (_,_,_,(_<:(_,_))) : (_,_,*,_) : (_, +, _) :
	//de.fdelay4(ma.SR/10),_)  ~_ ),_) : (*,*) : (-);
	de.delay(ma.SR/10),_)  ~_ ),_) : (*,*) : (-);
	// (_,_,_):((*),_):(-);

